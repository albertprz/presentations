#+REVEAL_HLEVEL: 1
#+REVEAL_INIT_OPTIONS: transition: 'cube'
#+REVEAL_THEME: moon
#+EXPORT_AUTHOR: Alberto Perez Lopez

#+title: Functional Design in Scala

* Explicit composition

- Some kind of composition is almost always necessary when designing complex systems

- Explicit composition can be a useful principle in order to achieve a simple, modular and clear design

- Scala favours explicit composition (usually through higher order combinators) in contrast to many other languages that incentivize a more implicit approach to composition of operations

* Composition in the small

** Contextual abstractions

- Notion of composing operations within an specific context

- Unified API completely agnostic about the context \\
   => Programming to an Interface, not an implementation

- The decision which context the operations will be ran on, can sometimes be taken by the caller for context polymorphic functions \\
   => Inversion of Control

*** Applicative style

Used for sequencing independent operations

Without a context
#+BEGIN_SRC scala
def createUser
  (userId: String): Unit =

  log.info ("Processing user: " + userId) ;
    persistUserInDB  (userId) ;
    sendNewUserEvent (userId)
#+END_SRC

Within a context
#+BEGIN_SRC scala
def createUser [F[_]: Applicative]
  (userId: String): F[Unit] =

  log.info ("Processing user: " + userId) *>
    persistUserInDB  (userId) *>
    sendNewUserEvent (userId)
#+END_SRC

*** Monadic style

Used for sequencing dependent operations

Without a context
#+BEGIN_SRC scala
def formatFile
  (inputPath: String, outputPath: String): Unit

  readFile(inputPath)
    .pipe(callFormatProcess)
    .pipe(writeFile(outputPath))
#+END_SRC

Within a context
#+BEGIN_SRC scala
def formatFile [F[_]: Monad]
  (inputPath: String, outputPath: String): F[Unit]

  readFile(inputPath)
    .flatMap(callFormatProcess)
    .flatMap(writeFile(outputPath))
#+END_SRC


*** Arrow style

Used for sequencing dependent operations \\
 (via function composition)

Without a context
#+BEGIN_SRC scala
def formatFile
  (outputPath: String): Function1[String, Unit]

  readFile
    .andThen(callFormatProcess)
    .andThen(writeFile(outputPath))
#+END_SRC

Within a context
#+BEGIN_SRC scala
def formatFile [F[_, _]: Arrow]
  (outputPath: String): F[String, Unit]

  readFile
    >>> callFormatProcess
    >>> writeFile(outputPath)
#+END_SRC


* Composition in the large

** Dependency Injection

- Notion of giving access to necessary capabilities / resources provided in an environment generated in the application entry point and cascaded down to each of the components in the application

- This environment of dependencies can be switched freely, for example for   mocking in tests or for staging / prod configurations

- Incentivizes thinking about the architecture of an application in terms of a hierarchical tree of components that just have access to a particular scope given by a limited set of capabilities and resources

*** Tagless Final

#+BEGIN_SRC scala
trait DBOps [F[_]]:
    def fetchAllDocuments: DbConnection ?=> F[Document]

trait LoggerOps [F[_]]:
    def log: Logger ?=> String => F[Unit]

object StagingLogger extends LoggerOps[IO]:
    def log = (logger: Logger) ?=> x => IO.delay(logger.log(x))

object ProdLogger extends LoggerOps[Id]:
    def log = (logger: Logger) ?=> x => ()

object TestLogger extends LoggerOps[IO]:
    val loggerQueue: Queue[IO, String]
    def log = (logger: Logger) ?=> x => loggerQueue.offer(x)


object DocumentService:
    def listDocuments [F[_]: DBOps : LoggerOps : Applicative]
        (using DbConnection, Logger): F[Document] =
      LoggerOps[F].log("Fetching documents ...") *>
      DBOps[F].fetchAllDocuments
#+END_SRC

*** ReaderT pattern


#+BEGIN_SRC scala
trait DBOps [F[_]]:
    def fetchAllDocuments: DbConnection ?=> F[Document]

case class AppEnv(config: Config,
                  db: DBOps,
                  logger: LoggerOps,
                  kafka: KafkaOps,
                  httpClient: HttpClient)

type AppM [A] = ReaderT [IO, AppEnv, A]

trait HasDBOps[F[_]]:
    def get [A] (x: F[A]): DbConnection ?=> F[Document]

object AppDBOps extends HasDBOps[AppM]:
    def get = (conn: DBConnection) ?=> liftIO(ask.map(_.db))


object DocumentService:
    def listDocuments [F[_]: HasDBOps : HasLoggerOps : Applicative]
        (using DbConnection, Logger): F[Document] =
      HasLoggerOps[F].get.log("Fetching documents ...") *>
      HasDBOps[F].get.fetchAllDocuments
#+END_SRC
